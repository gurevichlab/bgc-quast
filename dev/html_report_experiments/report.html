<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BGC-QUAST Report</title>
    <style>
    /* Entire page layout using Flexbox */
html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: #EDF2F4;
    font-family: "Courier New", "Lucida Console", monospace;
}

/* New wrapper to flexibly contain header, layout, and footer */
#main {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 10px;
}

/* Growable content area: table and plot */
#reportLayout {
    display: flex;
    gap: 0px;
    flex: 1; /* Takes up remaining vertical space */
}

#reportLayout > div {
    flex: 1;
}

/* Table styling (unchanged) */
h1 {
    color: #333;
    text-align: left;
}

table {
    width: 80%;
    border-collapse: collapse;
    margin-top: 10px;
}

th, td {
    border: 1px solid #878686;
    padding: 8px;
    text-align: left;
}

td {
    background-color: #f8f9fa;
}

th {
    background-color: #bdd1db;
}

/* Table style - rows */
.extended-row {
    display: none;
}

.extended-btn-wrapper {
    margin-top: 10px;
}


/*Heatmap style*/
.heatmap-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 10px;
}

.heatmap-legend-labels {
    font-size: 12px;
    display: flex;
    justify-content: space-between;
}

/* Sticky footer */
#footer {
    border-top: 1px solid #333;
    padding-top: 0px;
    font-size: 15px;
    text-align: left;
}


    </style>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<body>
<div id="main"> <!-- Wrapper -->
    <h1>BGC-QUAST Report</h1>

    <div id="reportLayout">
        <div>
            <div class="heatmap-controls">
                <!-- Gradient legend -->
                <div id="heatmapLegend">
                    <canvas id="gradientHeatmap" width="300" height="10"></canvas>
                    <div class="heatmap-legend-labels">
                        <span>Smallest</span>
                        <span>Median</span>
                        <span>Largest</span>
                    </div>
                </div>

                <!-- Heatmap toggle checkbox -->
                <label>
                    <input type="checkbox" id="heatmapToggle" checked> Show heatmap
                </label>


            </div>

            <div id="reportTableContainer"></div>
            <div class="extended-btn-wrapper">
                <button id="toggleExtendedBtn">Show Extended Report</button>
            </div>
        </div>

        <div>
            <canvas id="bgcBarPlot" width="600" height="300"></canvas>
        </div>
    </div>

    <div id="footer">
        <p>GitHub Project Page:<br>
            <a href="https://github.com/gurevichlab/bgc-quast">https://github.com/gurevichlab/bgc-quast</a>
        </p>
    </div>
</div>

    <!-- Data injected by Python -->
    <script>
        const reportData = [["Genome mining file", "assembly_10", "assembly_10", "assembly_10"], ["Genome mining tool", "antiSMASH", "DeepBGC", "GECCO"], ["# BGC (total)", "6", "6", "5"], ["# BGC (NRP)", "1", "1", "1"], ["# BGC (PKS)", "1", "1", "0"], ["Mean BGC length (total)", "29313.0", "27759.2", "26500.5"], ["Mean BGC length (NRP)", "52045.0", "50160.0", "48790.0"], ["# complete BGC (total)", "3", "2", "1"], ["# complete BGC (NRP)", "1", "1", "0"], ["# complete BGC (PKS)", "1", "1", "0"], ["# incomplete BGC (total)", "3", "4", "4"], ["# incomplete BGC (NRP)", "0", "0", "1"], ["# incomplete BGC (PKS)", "0", "0", "0"], ["Mean complete BGC length (total)", "30500.0", "29500.0", "27000.0"], ["Mean complete BGC length (NRP)", "52045.0", "50160.0", "0.0"], ["Mean incomplete BGC length (total)", "28200.0", "26000.0", "25500.0"], ["Mean incomplete BGC length (NRP)", "0.0", "0.0", "48790.0"]];
    </script>
    <script>
    // =======  Compute the median of a numeric array =======
function getMedian(arr) {
    const mid = Math.floor(arr.length / 2); // Calculate the middle index of the array
    return arr.length % 2 === 0
        ? (arr[mid - 1] + arr[mid]) / 2
        : arr[mid];
}

// ======= Convert hue + lightness to HSL color string =======
function getColor(hue, lightness = 92) {
    return `hsl(${hue}, 80%, ${lightness}%)`;
}

// ======= Draw the heatmap legend above the table =======
function drawHeatmapLegend(lowHue, topHue) {
    const canvas = document.getElementById('gradientHeatmap');
    const ctx = canvas.getContext('2d');

    const width = canvas.width;
    const height = canvas.height;

    const gradient = ctx.createLinearGradient(0, 0, width, 0);

    // Create 3-part gradient: Smallest (lowHue), Median (white), Largest (topHue)
    gradient.addColorStop(0, getColor(lowHue, 55));  // Smallest
    gradient.addColorStop(0.5, 'hsl(0, 0%, 100%)');  // Median = white
    gradient.addColorStop(1, getColor(topHue, 55));  // Largest

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

// ======= Apply background color to cells based on stats =======
function heatMapOneRow(cells, values, direction = 'more_is_better') {
    // Skip if too few values or all are the same (no variation to color)
    if (values.length < 2 || new Set(values).size === 1) return;

    // Sort values and calculate statistical parameters
    const sorted = [...values].sort((a, b) => a - b);
    const median = getMedian(sorted);
    const q1 = sorted[Math.floor((sorted.length - 1) / 4)];
    const q3 = sorted[Math.floor((sorted.length - 1) * 3 / 4)];
    const iqr = q3 - q1;

    // Calculate "fences" for mild/extreme outliers
    const lowOuter = q1 - 3 * iqr;
    const lowInner = q1 - 1.5 * iqr;
    const topInner = q3 + 1.5 * iqr;
    const topOuter = q3 + 3 * iqr;

    // Set up the color settings (hues/brightness)
    const YELLOW = 60, PURPLE = 280;
    const MID_BRT = 100, MIN_BRT = 75, INNER_BRT = 65, OUTER_BRT = 55;

    // Select hue direction depending on the metric
    const [lowHue, topHue] = direction === 'less_is_better' ? [PURPLE, YELLOW] : [YELLOW, PURPLE];

    // Apply coloring logic per cell
    for (let i = 0; i < cells.length; i++) {
        const cell = cells[i];
        const num = values[i];
        let hue, lightness;

        if (num < lowOuter) {
            // Extreme low outlier
            hue = lowHue; lightness = OUTER_BRT;
            cell.style.backgroundColor = getColor(hue, lightness);
            cell.style.color = 'white'; // improve contrast
        } else if (num < lowInner) {
            // Mid low outlier
            hue = lowHue; lightness = INNER_BRT;
            cell.style.backgroundColor = getColor(hue, lightness);
        } else if (num < median) {
            // Between low inner and median → interpolate brightness
            hue = lowHue;
            const k = (MID_BRT - MIN_BRT) / (median - lowInner);
            lightness = MID_BRT - (median - num) * k;
            cell.style.backgroundColor = getColor(hue, lightness);
        } else if (num > topOuter) {
            // Extreme high outlier
            hue = topHue; lightness = OUTER_BRT;
            cell.style.backgroundColor = getColor(hue, lightness);
            cell.style.color = 'white';
        } else if (num > topInner) {
            // Mild high outlier
            hue = topHue; lightness = INNER_BRT;
            cell.style.backgroundColor = getColor(hue, lightness);
        } else if (num > median) {
            // Between median and top inner → interpolate brightness
            hue = topHue;
            const k = (MID_BRT - MIN_BRT) / (topInner - median);
            lightness = MID_BRT - (num - median) * k;
            cell.style.backgroundColor = getColor(hue, lightness);
        }
        // If num === median → no color applied (keeps white)
    }
}

const allNumericCells = [];
// ======= Table Builder =======
function buildTable(data) {
    allNumericCells.length = 0;
    const container = document.getElementById('reportTableContainer');
    const table = document.createElement('table');
    const headerRow = document.createElement('tr');

    // Build column headers
    headerRow.appendChild(document.createElement('th')); // top-left empty cell
    data[0].slice(1).forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Loop over each data row
    for (let i = 1; i < data.length; i++) {
        const row = document.createElement('tr');
        const rowData = data[i];

        // Hide extended rows by default (toggle later)
        if (i > 6) row.classList.add('extended-row');

        const numericCells = [];
        const numericValues = [];

        // Build each cell in the row
        data[i].forEach((cell, j) => {
            const td = document.createElement(j === 0 ? 'th' : 'td');
            td.textContent = cell;

            // Only collect numeric values for heatmap
            if (j > 0) {
                const num = parseFloat(cell);
                if (!isNaN(num)) {
                    numericCells.push(td);
                    numericValues.push(num);
                }
            }

            row.appendChild(td);
        });

        // Apply the statistical heatmap coloring
        heatMapOneRow(numericCells, numericValues);
        allNumericCells.push({ cells: numericCells, values: numericValues });

        table.appendChild(row);
    }

    container.appendChild(table);
}

// ======= Bar Chart Builder =======
function buildBarPlot(data) {
    const row = data.find(r => r[0] === '# BGC (total)');
    if (!row) return;

    const tools = data[1].slice(1);
    const assemblies = data[0].slice(1);
    const labels = tools.map((tool, i) => `${tool}\n${assemblies[i]}`);
    const counts = row.slice(1).map(v => parseInt(v));

    new Chart(document.getElementById('bgcBarPlot'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: '# BGC (total)',
                data: counts,
                backgroundColor: '#6cae75'
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: ctx => `# BGCs: ${ctx.raw}`
                    }
                }
            },
            scales: {
                y: { beginAtZero: true }
            }
        }
    });
}

// ======= Setup on Page Load =======
document.addEventListener('DOMContentLoaded', () => {
    buildTable(reportData);
    buildBarPlot(reportData);

    // Toggle visibility of extended report rows
    const toggleBtn = document.getElementById('toggleExtendedBtn');
    toggleBtn.addEventListener('click', () => {
        const extendedRows = document.querySelectorAll('.extended-row');
        const isHidden = getComputedStyle(extendedRows[0]).display === 'none';

        extendedRows.forEach(row => {
            row.style.display = isHidden ? 'table-row' : 'none';
        });

        toggleBtn.textContent = isHidden ? 'Hide Extended Report' : 'Show Extended Report';
    });

    const heatmapToggle = document.getElementById('heatmapToggle');
    heatmapToggle.addEventListener('change', () => {
        const show = heatmapToggle.checked;
        allNumericCells.forEach(({ cells, values }) => {
            if (show) {
                heatMapOneRow(cells, values);
            } else {
                cells.forEach(cell => {
                    cell.style.backgroundColor = '';
                    cell.style.color = '';
                });
            }
        });
    });
    // Draw heatmap gradient
    drawHeatmapLegend(60, 280);  // yellow to purple


});

    </script>
</body>
</div>
</html>

